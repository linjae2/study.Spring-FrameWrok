/*
 * This source file was generated by the Gradle 'init' task
 */
package org.study;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class App {

  private static ExecutorService getExecutor() {
    final ExecutorService executor = Executors.newFixedThreadPool(1);
    return executor;
  }


  public static void main(String[] args) {
    System.out.println("================= START ======================");

    ExecutorService executor = getExecutor();

    executor.execute( () -> {
      try {
        TimeUnit.MILLISECONDS.sleep(10000);

        String threadName = Thread.currentThread().getName();
        System.out.println("Hello ================ " + threadName);

      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });


    IntStream.range(0, 10).forEach(n ->
      executor.execute( () -> {
        try {
          TimeUnit.MILLISECONDS.sleep(300);

          String threadName = Thread.currentThread().getName();
          System.out.println("Hello " + threadName);

        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      })
    );
    // // 수행시긴이 긴 task (약 3초)
    // Runnable task1 = () -> {
    //   System.out.println("start");
    //   try {
    //     Thread.sleep(3000);
    //   } catch (InterruptedException e) {
    //     e.printStackTrace();;
    //   }
    //   System.out.println("finish");
    // };

    // // // 0.1 초마다 한번씩 task를 수행시켜주길 바라고 만듦
    // // executor.scheduleAtFixedRate(task1, 0, 100, TimeUnit.MILLISECONDS);

    System.out.println("프로그램 종료!");
  }
}
